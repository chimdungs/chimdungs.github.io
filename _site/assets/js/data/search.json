[
  
  {
    "title": "MarchingCubes, SIGGRAPH 1987",
    "url": "/posts/MarchingCubes/",
    "categories": "Paper Review",
    "tags": "Mesh extraction, Graphics",
    "date": "2025-01-21 11:00:00 +0900",
    





    
    "snippet": "Abstract  output = 연속적인 density값을 갖는 surface의 triangle model  알고리즘 큰 흐름 : 3D medical data를 scan-line order에 처리한 후, 선형 보간(linear interpolation)을 이용해서 삼각형의 vertices(꼭짓점)을 구하는 것Introduction  mesh extr...",
    "content": "Abstract  output = 연속적인 density값을 갖는 surface의 triangle model  알고리즘 큰 흐름 : 3D medical data를 scan-line order에 처리한 후, 선형 보간(linear interpolation)을 이용해서 삼각형의 vertices(꼭짓점)을 구하는 것Introduction  mesh extraction하는 것은 medical image에서 굉장히 유용하게 많이 쓰임  새로운 3D surface construction 알고리즘인 “Marching Cube”는 연속적인 density surface를 가지는 물체에 대한 vertices를 추출함으로써 고해상도의 메쉬 만듦  3D Medical 알고리즘 흐름 :                            Data Acquistion          MR, CT, SPECT같은 기기로 환자 데이터 얻음                                      Image Processing          3D data의 전체적인 구조를 파악할 수 있는 기법 사용                                      Surface Construction          본 논문의 주제, 적절한 알고리즘 사용                    Display      Related Work      기존의 연구 (1) Connected Contour 알고리즘 : surface의 윤곽(contour)에서 시작하여 그것들이 서로 연속적인 삼각형이 되게 연결하는 접근법   -&gt; slice에 하나 이상의 contour가 존재해야하는데 이때 ambiguity(모호성)이 발생하여 정확도 떨어짐   -&gt; 원데이터의 inter-slice의 연결성을 무시함    (2) Cuberille 접근법 : cuberilles(작은 큐브인 voxel형태로 표현하는 구조)로부터 surface 구축하는 접근법   -&gt; 이 구조에서 gradient를 계산했을 때 그 값이 shading(그림자)영역의 지점을 찾는데에 이용되는데, 이게 정확하기가 쉽지 않음   -&gt; thresholding해서 3D space를 블록 단위 voxel처럼 표현하고 surface을 표현    (3) Ray casting   -&gt; 3차원 sensation을 생산하기 위해 motion에 의존함(?)   Marching Cubbe Algorithm (Method)  크게 2가지의 주요한 단계로 구성됨  divide-and-conquer 접근법  3D space상의 큐브 하나에서 다음 큐브로 넘어갈 때, surface가 어떻게 교차하는지를 찾는 것이 목표      이웃한 8개 픽셀(두 Slice 면의 4개 꼭짓점)로부터 logical한 cube가 Figure-2처럼 위치하게 세팅,        큐브의 꼭짓점(vertex) 데이터 값이 우리가 구성하는 surface의 vertex value값을 초과하면 1을 부여  마찬가지로 큐브 vertex value가 surface vertex value값보다 아래이면 0을 부여=&gt; surface의 외부에 존재하는 점 대략 이러한 과정으로 교차점들을 통해 surface를 복원하게 된다. 큐브마다 8개의 vertices &amp; 2개의 state(inside, outside)가 존재하기 때문에, 표면이 꼭짓점 1개 당 $2^8$가지 경우의 수로 교차될 수 있다.  해당 256가지 경우의 수에 대한 table을 만들 수 있으나 매우 따분하고 에러가 발생하기 쉽기 때문에 , 256가지 경우의 수를 14가지 패턴으로 줄일 수 있는 다음의 두 가지 대칭 속성을 이용함          큐브가 reverse로 뒤집혀도, surface value들은 그대로 동일하게 바뀌지 않음              Rotational 대칭                        ‘’‘(ex) 0번 패턴 : 모든 vertices가 0으로 선택된 케이스(혹은 모두 1) =&gt; 삼각형을 생산하지 않게 됨          1번 패턴 : surface가 1개의 vertex를 나머지 7개의 vertices에 대해 분리시킨 상태 =&gt; 작은 삼각형 1개           ….  이 때, 윗 그림처럼 8개 vertices(v1~v8)와 각 vertex 사이의 bit index 12개(e1~e12)를 numbering하여 edge intersection을 고려한다.  그 후 surface와 맞닿는 edge가 어떤 것인지 알았으면, 이 edge들 사이에서 linear interpolation(선형 보간)을 수행한다.  마지막 단계로 각 triangle vertex에 대한 unit normal(단위 법선벡터)를 계산한다.          이렇게 구한 normal로 Gouraud-shaded image를 렌더링할 때 사용됨, 즉 명암 넣기 단계임                  고러드 쉐이딩(Gouraud Shading)                    Details :                  surface 의 normal은, surface의 접선 방향에 대한 gradient vector이다.                      direction of gradient vector를 $\\vec{g}$로 표기\\[\\vec{g}(x,y,z) = \\Delta{\\vec{f}(x, y,z)}\\]                                    $\\Delta{\\vec{f}(x,y,z)}$ 를 구하기 위해 3방향에서의 gradient vector를 아래처럼 계산한 후에 선형보간을 하여 surface 복원    \\(G_x(i,j,k) = \\frac{D(i+1, j, k) - D(i-1, j, k)}{\\Delta{x}}\\)     \\(G_x(i,j,k) = \\frac{D(i, j+1, k) - D(i, j-1, k)}{\\Delta{x}}\\)    \\(G_x(i,j,k) = \\frac{D(i, j, k+1) - D(i, j, k-1)}{\\Delta{x}}\\)        In summary, marching cubes creates a surface from a three-dimensional set of data as follows: (논문 표현)          Read four slices into memory.      Scan two slices and create a cube from four neighbors on one slice and four neighbors on the next slice.      Calculate an index for the cube by comparing the eight density values at the cube vertices with the surface con- stant.      Using the index, look up the list of edges from a precal- culated table.      Using the densities at each edge vertex, find the surface- edge intersection via linear interpolation.      Calculate a unit normal at each cube vertex using central differences. Interpolate the normal to each triangle ver- tex.      Output the triangle vertices and vertex normals      Enhancements to the Basic Algorithm  "
  },
  
  {
    "title": "SuGaR, CVPR 2024",
    "url": "/posts/SuGaR/",
    "categories": "Paper Review",
    "tags": "Mesh reconstruction, 3D Gaussian Splatting",
    "date": "2025-01-20 11:00:00 +0900",
    





    
    "snippet": "Abstract  precise and extremely fast mesh extraction from 3DGS representation  state-of-the-art method on SDFs, while providing a better rendering qualityContributions  Regularization term         ...",
    "content": "Abstract  precise and extremely fast mesh extraction from 3DGS representation  state-of-the-art method on SDFs, while providing a better rendering qualityContributions  Regularization term          Gaussian Splatting 최적화 중의 loss term에 추가시켜서 3D Gaussian들이 표면에 잘 정렬되게 하는 역할      3D Gaussian의 surface geometry(density &amp; SDF)를 이용함        Refinement strategy          mesh에 있는 gaussian들 삼각형으로 묶어주면서 refinement함      Introduction  mesh extraction task는 3DGS representation의 explicit한 특성 때문에 더 어려움  3DGS가 잘 최적화되었으면, 가우시안들이 평평하고 표면에 잘 분포되어있다는 가정을 얻을 수 있음          이때 gaussian density와 관련된 geometry를 이용해서 Loss term에 추가하면서 gaussian으로부터 mesh추출이 더 쉬워지게 만듦      volumne density 사용?        Marching Cube 알고리즘 대신 Poisson Reconstruction 알고리즘 사용해서 point cloud로부터 mesh extraction을 했다Method1. Aligning the Gaussians with the Surface (=Regularization)  목표 : 3DGS가 잘 최적화되어있다는 가정 하에, Gaussian의 SDF(Signed Distance Function)를 이끌어내는 것      optimized된 가우시안으로부터 예측된 SDF와 실제의 SDF간의 차이를 최소화함으로써 가우시안들이 평평하게 surface align된 특성을 갖을 수 있도록 encourage        최적화된 Gaussian Splatting Scene이 주어져있는 상황에서 시작    Gaussian의 density function $d(p)$ :\\[d(p) = \\sum_g \\alpha_g exp(-\\frac{1}{2}(p-\\mu_g)^T\\sigma_g^{-1}(p-\\mu_g))\\]  &lt; Property 1 &gt;1️⃣surface에 가까운 point $p$에 가까이 위치한 Gaussian $g^*$이 density function $d(p)$에 기여하는 정도가 크다\\[g^* = \\arg\\min_g(p-\\mu_g)^T\\sigma_g^{-1}(p-\\mu_g)\\]해석 = g*말고 나머지 가우시안들, g들에 대한 밀도가 최소가 되게 하면 된다.⇒ 이 성질을 만족하면, 가우시안들이 scene에서 잘 spread되어있다, 즉 scene에 가우시안들이 잘 퍼져있다는 가정을 만족&lt; Property 2 &gt;2️⃣잘 최적화된 3DGS scene에서는 Gaussian들이 평평하다 = scaling factor 3방향 벡터 중에서 하나는 0에 가까워야 함, (길이 짧아야 함)\\[(p-\\mu_g)^T\\Sigma_g^{-1}(p-\\mu_g) \\approx \\frac{1}{s_g^2}&lt;p-\\mu_g, n_g&gt;\\][notation]  $s_g$: 가장 짧은 scaling factor  $n_g :$ scaling factor에 대응되는 축에 대한 방향, normal(법선 벡터)처럼 생각해도 됨⇒ 결과적으로 surface-align한 density function $\\overline{d}(p)$\\[\\overline{d}(p) = exp(-\\frac{1}{2s_{g^*}^2} &lt;p-\\mu_{g^*}, n_{g^*}&gt;^2)\\]  A : d(p) 밀도함수를 따르는 가우시안,  B : $\\overline{d}(p)$ 밀도함수를 따르는 가우시안&lt; Optimize Term &gt;  $|d(p) - \\overline{d}(p)|$: 위의 density volume을 이용한 optimization term 을 3DGS loss에 추가          밀도를 이용하는 지금 optimize term 일단 좋긴 좋은데,,,density말고 SDF(Signed Distance Function) 활용하는 것도 추가시키면 surface-align Gaussian을 얻는 것에 더 좋다고 함    - 평평한 가우시안이 주어졌을 때, 즉 Gaussian $g$의 scaling factor들이 $s_g$ = 0 인 상황에서, point $p$와 true surface와의 거리 : $|&lt;p-\\mu_{g’}, n_{g’}&gt;|$      \\[SDF : \\overline{f}(p) = \\pm s_{g^*}\\sqrt{-2log(\\overline{d}(p))}\\]\\[ideal-SDF : {f}(p) = \\pm s_{g^*}\\sqrt{-2log({d}(p))}\\]   $|\\overline{f}(p)-f(p)|$ : 위의 SDF를 이용한 optimization term을 통해 표면에 더 잘 정렬된 가우시안들을 얻을 수 있었다.   Regularization term $R$ :\\[R =  \\frac{1}{|P|} \\sum_{p \\in P} |\\overline{f}(p) - f(p)|\\]      SDF의 normal(법선 벡터)에 대한 regularization term도 있음\\[R_{Norm} = \\frac{1}{|P|}  \\sum_{p\\in P} || \\frac{\\nabla f(p)}{|| \\nabla f(p) ||^2} - n_{g^*} ||_2^2\\]  2. Efficient Mesh Extraction (=Poisson Reconstruction)  최적화된 3DGS scene에서 계산된 가우시안들의 density로부터 3D points를 일정 level set에 대하여 샘플링함 =&gt; point clouds 구함                  이 때, level set은 level parameter인 $\\lambda$에 의해 결정됨                          샘플링된 Points 기반으로 Poisson reconstruction 수행하여 mesh 추출    참고. Poisson Reconstruction 정리 글  3. Binding New Gaussians to the Mesh (=Refinement)  Barycentric 좌표계 :  삼각형 또는 다면체 내부의 점을 해당 도형의 꼭짓점에 대한 가중치로 표현하는 좌표계          (ex) 삼각형의 경우:                              삼각형의 꼭짓점을 A, B, C라 할 때, 내부의 임의의 점 P는 다음과 같이 표현됩니다:            $P = \\alpha A + \\beta B + \\gamma C$                                여기서 α,β,γ는 가중치로, 아래 조건을 만족합니다:            $\\alpha + \\beta + \\gamma = 1$                                    논문 표현 :    Also, the Gaussians have only 2 learnable scaling factors instead  of 3 and only 1 learnable 2D rotation encoded with a complex number rather than a quaternion, to keep the Gaussians flat and aligned with the mesh triangles.        quaternion이란: 3D 회전을 표현하기 위해 사용되는 수학적 구조로, 복소수의 확장된 형태    $q=w+xi+yj+zk$  Experiment  single GPU Nvidia Tesla V100 SXM2 32 Go느낀점  3DGS에서 거의 최초로 mesh reconstruction태스크를 수행해서 성능이 좋게 나왔다는 것이 의의  요즘 모델들의 거의 baseline 시초급(?)으로 봐도 무방하다  포아송 재건방법이 아직 뭔지 잘 모르겠다. marching cube공부할 때 같이 공부  어렵긴 한데 재밌다."
  },
  
  {
    "title": "GS2Mesh, ECCV 2024",
    "url": "/posts/GS2Mesh/",
    "categories": "Paper Review",
    "tags": "Mesh reconstruction, Surface reconstruction, 3D Gaussian Splatting",
    "date": "2025-01-19 15:00:00 +0900",
    





    
    "snippet": "GS2Mesh :Surface Reconstruction from Gaussian Splatting via Novel Stereo Views&lt; 선정 이유 &gt;  SuGaR (CVPR 2024)논문 이후로 유의미하게 3dgs의 mesh recon 태스크에서 성능이 sota달성하였다는 점,  baseline에 SuGaR가 존재한다는 점Abstra...",
    "content": "GS2Mesh :Surface Reconstruction from Gaussian Splatting via Novel Stereo Views&lt; 선정 이유 &gt;  SuGaR (CVPR 2024)논문 이후로 유의미하게 3dgs의 mesh recon 태스크에서 성능이 sota달성하였다는 점,  baseline에 SuGaR가 존재한다는 점Abstract  noisy한 3DGS representation으로부터 smooth한 3D mesh representation을 얻는 것 어려움  pre-trained stereo-matching model사용해서 scene에 대한 geometry 활용함          stereo-aligned 되어있는 image pair를 얻고, 이를 앞선 stereo matching모델에 넣어서 depth추출하여 geometry 이용함        more smoother, more accurate mesh extraction 가능          Mesh Extraction 알고리즘 : TSDF(Truncated Signed Distance Function) 이용한 Marching cube      Contributions  pre-trained stereo-matching 모델을 통해 Image pair의 geometry 활용해서 mesh reconstruction 태스크의 sota성능을 달성하였다.          사용한 스테레오 매칭 모델 : DLNR                  stereo calibrated image pair를 모델 input으로 사용하여 이미지 쌍에 대한  correspondence 문제를 해결 + depth 추출                      TSDF(Truncated Signed Distance Function)와 depth 정보를 활용해서 mesh recon하는 알고리즘 (marching cube기반) 사용하였다. Introduction  Gaussian의 explicit한 요소만으로 geometrically consistent한 surface를 추출하는 것은 어려움          image plane(2D)에 back projected 되었을때 best matching되게끔 최적화된 가우시안이기 때문에, mesh reconstruction 에서는 오히려 가우시안 representation이 단점이 됨            stereo-aligned된 이미지 쌍에서 stereo-matching 모델(DLNR)을 사용해서 정확한 depth 측정한 후, TSDF 활용한 Depth-fusion기반 mesh extraction 알고리즘 (Marching cube) 사용하는 파이프라인    데이터셋 : TnT(Tanks and Temples) &amp; DTU(작은 object mesh 데이터셋임) 에서 sota성능을 보여주었다.MethodStep 1. Scene Capture &amp; Pose Estimation  COLMAP의 SFM(Structure From Motion)을 통해 카메라 파라미터들을 얻어내고, sparse한 3D point cloud를 재건한다.Step 2. Stereo-aligned Image Pairs 생성  3DGS에서 photometric loss를 통해 최적화되어서 image plane에 back-projected된 가우시안들 기반으로 stereo-aligned(같은 베이스라인b 선상에 존재하는, 카메라 포즈(rotation, translation)은 그대로에 baseline b길이만큼만 떨어진) 한 쌍으로 만드는 과정을 수행한다.          \\[R_R = R_L\\]\\[T_R = T_L + (R_L \\times [b, 0, 0])\\]   수식 Notation 설명   - $R_R$: 오른쪽 카메라의 rotation matrix    - $R_L$: 왼쪽 카메라의 rotation matrix    - $T_R$: 오른쪽 카메라의 translation matrix    - $T_L$: 왼쪽 카메라의 translation matrix  Step 3. Stereo Depth Estimation  input : a pair of stereo-calibrated cameras      DLNR(High Frequency Stereo matching Network) 모델 이용        DLNR pipeline          multiscale decouple LSTM 구조를 따름 + Disparity Normalization 수행하는 것이 핵심      논문까지 자세힌 아직 안읽어봄, 걍 stereo matching model 성능 중에 sota라고 함            이 모델 output에다가 아래의 mask 2개 정도 추가시켜 reconstruction성능 향상              occlusion mask                  left-to-right disparity랑 right-to-left disparity 차이 이 두개 사이에서 thresholding해서 구해짐                    depth-shading                  stereo-matching error $\\epsilon(Z)$        \\[\\epsilon(Z) = \\frac{\\epsilon(d)}{f_x \\cdot B} Z^2\\]                  $Z$ :  ground-truth depth          $d$ : disparity          $f_x$ : 수평축 카메라 focal length       - error가 baseline B 길이 값이 커질수록, 즉 stereo-paired image 사이의 간격이 클수록 에러가 작아지는 반면, occlusion이 심해질 수 있음          4B ≤ Z ≤ 20B 에 속하는 깊이만을 고려함                    Step 4. Depth Fusion into Triangulated Surface (mesh)  추출된 depth 정보들을 TSDF(Truncated Signed Distance Function) 기반 mesh reconstrucction 방법에 통합시킨다                  TSDF Cube Model이란?        : 깊이 영상 으로부터 3차원 공간 표면을 효과적으로 표현하기 위해,        전체 공간을 일정한 크기의 정육면체 복셀(voxel)들로 구성된 커다란 하나의 큐브(cube)로 표현하고, 각 복셀에는 물체 표면과의 거리를 나타내는 TSDF값과 그 값의 신뢰도를 나타 내는 가중치(weight)를 함께 저장하는 방식                    etc에 TSDF 개념 간단하게 추가              Marching cube : mesh 만들어주는 알고리즘          sdf나 tsdf같은 함수 활용되며, surface representation 방식 기반으로 mesh 뽑아냄      Experiment  ground truth point cloud랑 reconstructed point cloud간의 Chamfer Distance(CD)계산을 통해 evaluation  Baseline : SuGaR(CVPR 2024), BakedSDF, Neuralangelo, VolSDF, NeuS, MVSformer,  데이터별로 실험 진행 얘기  평가 지표 : Chamfer-Distance(CD): 두 point cloud 집합간의 거리 측정, F1, AccuracyLimitation  오른쪽 스테레오 매칭 모델은 투명한 표면에서 어려움을 겪는다.  (왼쪽) 원래 학습 이미지에서 충분히 다루어지지 않은 영역에서 floater를 생성한다.  TSDF 퓨전은 큰 장면(넓은 baseline B)에 맞게 확장되지 않는다.etc., (Preliminaries)기초개념 정리기초 개념      Mesh란?    : 3D 공간상에 존재하는 점들(Vertex/ Point) 과 그 점 3 개의 집합인 면(Polygon/face)들로 이루어진 3D 공간 표현방법        Voxel이란?    :이미지의 pixel 처럼 3D 공간을 표현하기 위해서 3D공간을 작은 단위 공간으로 쪼갠 것 –&gt; 3차원 공간을 grid로 쪼갰다고 보면 편함  TSDF (Truncated Signed Distance Function)  3D scene reconstruction의 목적은 Surface 를 찾아 recon 하는 것인데 이때 surface 를 표현하는 함수를 SDF(Signed Distance Function) 라고 함      Voxel 형태로 단위공간을 나누어 surface 라고 판단되는 곳은 0, Surface 안쪽은 음수 , Surface 바깥쪽은 양수로 표현하는 방식      Marching Cube (SIGGRAPH 1987)  과정 다 생략하고 한 줄 요약 : 3D point cloud로부터 Mesh 생성 알고리즘2차원 image plane에서 물체가 빨간색 선처럼 생겼다고 생각해보자, (3차원에서는 voxel임)이것을 2차원 도트로 표현하면 아래와 같음⇒ 원형의 물체랑 너무 달라짐, 해상도 차이 발생, 모양 이상해지는 결과따라서, 마칭 큐브 알고리즘으로 surface reconstruction을 진행한다. (…TLDR)  About Marching Cube Algorithm, tistory=&gt; 마칭 큐브 알고리즘 다음 게시물에 정리 이어서,, 느낀점  Marching Cube 알고리즘부터 완벽하게 이해를 해보자          항상 간단한 정리글로만 읽고 넘어가니까 그냥 point cloud넣고 mesh뽑아주는 그래픽스 알고리즘이다정도라고만 알고 넘어가서 모호하다, 알짜배기를 모르는 느낌      SuGaR에서는 Poisson reconstruction기반의 mesh recon알고리즘을 썼다고 되어있었는데, 이게 나는 마칭 큐브랑 완전 다른 건 줄 알았는데 또 읽다보니 포아송재건도 마칭큐브기반이라는 소리도 있고 출처가 정확하지 않으니까 혼동된다, 그래서 Poisson Reconstruction 논문도 읽어야겠다        eccv논문인데 생각보다 노벨티가 뭐가 없다          그냥 stereo-matching 모델 써서 depth추출하고 이거 기반으로 point cloud를 더 정확하고 밀도있게 뽑아내고 그 후로는 그냥 알고리즘 사용해서 메쉬추출한건데,, 성능이 좋았다는게 신기하다.      대신 단점이 명확하다, stereo 기법이다보니 위의 triangulation사진을 보다시피 베이스라인 길이에 한정된 씬만 사용될 것이므로 넓은 즉 큰 반경의 scene에 대한 mesh recon은 잘 안될 것이다 (실제로 사용한 데이터셋들도 다 작은 object based 벤치마크들이다)      3DGS도 그렇고, mesh recon도 그렇고 고질적인 문제가 투명한 transparent한 물체가 잘 복원이 어렵다는 점인데, 이부분의 개선은 왜 안되고 있는지 렌더링 측면에서 공부를 좀 더 해봐야겠다.      "
  },
  
  {
    "title": "블로그 오픈",
    "url": "/posts/First_Blog/",
    "categories": "Blogging, Tutorial",
    "tags": "personal",
    "date": "2025-01-18 02:34:00 +0900",
    





    
    "snippet": "First Blog안녕~! 데스크탑 운영체제가 리눅스여서 도커 연동이 생각만큼 잘 되지 않아 깃헙 블로그를 만드는 걸 계속 미뤄왔었다. 오늘 맥북이 새로 와서 심심해가지고 블로그 미뤄뒀던 걸 다시 도전해봤다. 아직 favicon은 반영은 뭐땜시 아직 안되고 있고,, 그대로 테마 갖다 쓰는건데도 생각보다 뭐가 잘 안되서..생각보다 오래걸렸다. 글 쓰고 ...",
    "content": "First Blog안녕~! 데스크탑 운영체제가 리눅스여서 도커 연동이 생각만큼 잘 되지 않아 깃헙 블로그를 만드는 걸 계속 미뤄왔었다. 오늘 맥북이 새로 와서 심심해가지고 블로그 미뤄뒀던 걸 다시 도전해봤다. 아직 favicon은 반영은 뭐땜시 아직 안되고 있고,, 그대로 테마 갖다 쓰는건데도 생각보다 뭐가 잘 안되서..생각보다 오래걸렸다. 글 쓰고 올리는 건 자동화가 잘돼있어서 괜찮을 것 같아 꾸준히 스터디 겸 근황을 이곳에 올리도록 하겠다.맥도 아직 익숙하지 않아서 다소 헤맸지만 좀 더 익숙해지면 활용도가 매우 높을 것 같아 만족한다!  WELCOME MY GITHUB BLOG, I am a Master student in Computer Vision Lab, Korea UniversityNext time you visit our site, this place will be much more developed and awesome."
  }
  
]

